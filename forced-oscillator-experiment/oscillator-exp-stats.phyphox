<phyphox version="1.12" locale="en">
    <title>Oscillator Experiment (with Stats)</title>
    <category>Phyphox Arduino Experiments</category>
    <icon format="base64">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</icon>
    <description>
            Displays the frequency spectrum of data from the accelerometer.
            This experiment records data from the accelerometer and calculates its frequency spectrum through a Fast Fourier Transformation (FFT). The maximum detectable frequency depends on the maximum acquisition rate of your sensor.
            A Stats View is also produced with gives readings of the average peak frequency and average max FFT along with their errors calculated via standard deviations
    </description>


    <data-containers>
        <!-- buffers for the raw accelerometer data -->
        <container size="0">time</container>
        <container size="0">accX</container>
        <container size="0">accY</container>
        <container size="0">accZ</container>
        <container size="0">acc</container>
        <container size="500">anyAcc</container>

        <!-- buffers for the peak frequency and stats -->
        <container size="0">f0</container>
		<container size="0">f0_avg</container>
		<container size="0">f0_error</container>

        <!-- buffers for other frequencies -->
        <container size="2048">halfFrequency</container>
        <container size="1">period</container>
        <container size="1">maxf</container>
        <container size="4096">frequency</container>

        <!-- buffers for sampling and counts -->
        <container size="4096">time_subrange</container>
        <container size="1">subrange_start</container>
        <container size="4096">accX_subrange</container>
        <container size="4096">accY_subrange</container>
        <container size="4096">accZ_subrange</container>
        <container size="1">recording_length</container>
        <container init="256">samples</container>
        <container size="1">actual_samples</container>
        <container size="1">actual_samples+1</container>
        <container size="1">arate</container>
        <container size="1">count-1</container>
        <container size="1">count</container>
        <container size="1">count/2</container>
        <container size="1">dt</container>
        <container size="1">Dt</container>
        <container size="1">t0</container>
        <container size="1">t1</container>

        <!-- FFT, calculations and stats buffers -->
        <container size="2048">fft</container>
		<container size="2048">maxfft</container>
		<container size="2048">maxfft_avg</container>
		<container size="2048">maxfft_error</container>
        <container size="2048">fftX</container>
        <container size="2048">fftY</container>
        <container size="2048">fftZ</container>
        <container size="2048">fft2</container>
        <container size="4096">fftXX</container>
        <container size="4096">fftYX</container>
        <container size="4096">fftZX</container>
        <container size="4096">fftXY</container>
        <container size="4096">fftYY</container>
        <container size="4096">fftZY</container>
        <container size="2048">halfFFTtempX</container>
        <container size="2048">halfFFTtempY</container>
        <container size="2048">halfFFTtempX2</container>
        <container size="2048">halfFFTtempY2</container>
    </data-containers>


    <!-- connecting the arduino's accelerometer to the Phyphox app -->
    <input>
        <bluetooth mode="notification" id="nano_ble" subscribeOnStart="false">
            <output char="cddf1002-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian" offset="0">time</output>
            <output char="cddf1002-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian" offset="4">accX</output>
            <output char="cddf1002-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian" offset="8">accY</output>
            <output char="cddf1002-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian" offset="12">accZ</output>
            <output char="cddf1002-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian" offset="16">acc</output>
        </bluetooth>
    </input>
	
    <output>
        <bluetooth id="nano_ble">
            <config char="cddf1003-30f7-4671-8b43-5e40ba53514a" conversion="float32LittleEndian">1.0</config>
        </bluetooth>
    </output>


    <views>
        <!-- creates a view will all the outputted data presented -->
        <view label="All">
            <graph label="Acceleration" labelX="Time" unitX="s" labelY="Acceleration" unitY="m/s²" partialUpdate="true" style="lines">
                <input axis="x">time_subrange</input>
                <input axis="y" style="lines" linewidth="2">anyAcc</input>
            </graph>

            <separator height="2"/>


            <graph label="Fourier Transform" logX="false" logY="true" labelX="Frequency" unitX="Hz" labelY="FFT Amplitude" unitY="a.u.">
                <input axis="x">halfFrequency</input>
                <input axis="y" style="lines" lineWidth="2">fft</input>
            </graph>
            <separator height="1"/>
            <value label="Peak Frequency" unit="Hz" precision="3"><input>f0</input></value>
            <value label="Number of Samples"><input>actual_samples</input></value>
            <value label="Period" unit="s" precision="2"><input>period</input></value>
            <value label="Nyquist frequency" unit="Hz" precision="0"><input>maxf</input></value>
			<value label="Max FFT" unit="a.u." precision="2"><input>maxfft</input></value>
			
			<separator height="2"/>


            <graph label="Frequency" logX="false" logY="true" labelX="Time" unitX="s" labelY="Peak Frequency" unitY="Hz">
                <input axis="x">time_subrange</input>
                <input axis="y" style="lines" lineWidth="2">f0</input>
            </graph>
			
			<separator height="3"/>
						
			
			<info label="Statistics"/>
			<separator height="1"/>
			<value label="Average Peak Frequency" unit="Hz" precision="3"><input>f0_avg</input></value>
            <value label="Peak Frequency Error" unit="Hz" precision="3"><input>f0_error</input></value>
			<value label="Average Max FFT" unit="a.u." precision="3"><input>maxfft_avg</input></value>
            <value label="Max FFT Error" unit="a.u." precision="3"><input>maxfft_error</input></value>
        </view>
		

		<!-- creates a new view with just the new statistical data -->
		<view label="Stats">
            <value label="Peak Frequency" unit="Hz" precision="3"><input>f0</input></value>
            <value label="Number of Samples"><input>actual_samples</input></value>
            <value label="Period" unit="s" precision="2"><input>period</input></value>
            <value label="Nyquist frequency" unit="Hz" precision="0"><input>maxf</input></value>
			<value label="Max FFT" unit="a.u." precision="2"><input>maxfft</input></value>
			
			<separator height="2"/>


            <!-- creates a graph of peak frequency with respect to time so that we can see the initial fluctuation before the value settles -->
            <graph label="Peak Frequency" logX="false" logY="true" labelX="Time" unitX="s" labelY="Peak Frequency" unitY="Hz">
                <input axis="x">time_subrange</input>
                <input axis="y" style="lines" lineWidth="2">f0</input>
            </graph>
			
			<separator height="3"/>
						
			
            <!-- outputs the statistical data for the peak frequency and its corresponding FFT value -->
			<info label="Statistics"/>
			<separator height="1"/>
			<value label="Average Peak Frequency" unit="Hz" precision="3"><input>f0_avg</input></value>
            <value label="Peak Frequency Error" unit="Hz" precision="3"><input>f0_error</input></value>
			<value label="Average Max FFT" unit="a.u." precision="3"><input>maxfft_avg</input></value>
            <value label="Max FFT Error" unit="a.u." precision="3"><input>maxfft_error</input></value>
        </view>
    </views>


    <analysis sleep="0.1">
        <!-- Since we want to keep a sign, but also want to allow using any axis, we simply look at the sum of all axes. This gives bad results if the phone is mounted at an angle, but usually the user will perform the experiment along a single axis -->
        <add>
            <input clear="false">accX</input>
            <input clear="false">accY</input>
            <input clear="false">accZ</input>
            <output>anyAcc</output>
        </add>

        <!-- sets the sample size to 800 samples -->
		<add>
            <input type="value">800</input>
            <output>samples</output>
        </add>
		
        <!-- counts the number of values in the raw x-component data buffer -->
        <count>
            <input clear="false">accX</input>
            <output>count</output>
        </count>

        <!-- subtracts 1 from the count -->
        <subtract>
            <input clear="false">count</input>
            <input type="value">1</input>
            <output>count-1</output>
        </subtract>

        <!-- returns the first value of the time as t0 -->
        <first>
            <input clear="false">time</input>
            <output>t0</output>
        </first>
        
        <!-- returns all values in a 1 count step to give t1 -->
        <subrange>
            <input as="from" clear="false">count-1</input>
            <input as="length" type="value">1</input>
            <input as="in" clear="false">time</input>
            <output>t1</output>
        </subrange>

        <!-- calculates Dt from the difference between t0 and t1-->
        <subtract>
            <input clear="false">t1</input>
            <input clear="false">t0</input>
            <output>Dt</output>
        </subtract>

        <!-- calculates dt -->
        <divide>
            <input clear="false">Dt</input>
            <input clear="false">count-1</input>
            <output>dt</output>
        </divide>

        <!-- counts the number of values in the raw x-component data buffer and gives the result as the recording length -->
        <count>
            <input clear="false">accX</input>
            <output>recording_length</output>
        </count>

        <!-- calculates the start based on the recording length and sample size -->
        <subtract>
            <input>recording_length</input>
            <input clear="false">samples</input>
            <output>subrange_start</output>
        </subtract>


        <!-- returns all the values in each acceleration component (including the absolute from the designated start -->
        <subrange>
            <input clear="false" as="from">subrange_start</input>
            <input as="in" clear="false">accX</input>
            <output>accX_subrange</output>
        </subrange>

        <subrange>
            <input clear="false" as="from">subrange_start</input>
            <input as="in" clear="false">accY</input>
            <output>accY_subrange</output>
        </subrange>

        <subrange>
            <input clear="false" as="from">subrange_start</input>
            <input as="in" clear="false">accZ</input>
            <output>accZ_subrange</output>
        </subrange>

        <subrange>
            <input clear="false" as="from">subrange_start</input>
            <input as="in" clear="false">time</input>
            <output>time_subrange</output>
        </subrange>

        <!-- returns the number of values in the X-component acceleration from the designated start to give the true sample size -->
        <count>
            <input clear="false">accX_subrange</input>
            <output>actual_samples</output>
        </count>

        <!-- adds 1 to the actual number of samples -->
        <add>
            <input clear="false">actual_samples</input>
            <input type="value">1</input>
            <output>actual_samples+1</output>
        </add>

        <!-- calculates the period from the actual number of samples and dt -->
        <multiply>
            <input clear="false">actual_samples</input>
            <input clear="false">dt</input>
            <output>period</output>
        </multiply>


        <!-- calculates the Fast Fourier Transform for each accelerometer component from the designated start -->
        <fft>
            <input clear="false">accX_subrange</input>
            <output as="re">fftXX</output>
            <output as="im">fftXY</output>
        </fft>

        <fft>
            <input clear="false">accY_subrange</input>
            <output as="re">fftYX</output>
            <output as="im">fftYY</output>
        </fft>

        <fft>
            <input clear="false">accZ_subrange</input>
            <output as="re">fftZX</output>
            <output as="im">fftZY</output>
        </fft>

        <!-- recalculates the count from the number of values within the fftXX buffer -->
        <count>
            <input clear="false">fftXX</input>
            <output>count</output>
        </count>

        <!-- calculates half the count from half the actual number of samples -->
        <divide>
            <input clear="false">actual_samples</input>
            <input type="value">2</input>
            <output>count/2</output>
        </divide>

        <!-- calculates the maxf -->
        <divide>
            <input type="value">0.5</input>
            <input clear="false">dt</input>
            <output>maxf</output>
        </divide>

        <!-- calculates the arate from 1/dt -->
        <divide>
            <input type="value">1</input>
            <input clear="false">dt</input>
            <output>arate</output>
        </divide>

        <!-- creates a linear range of values from 0 to arate with the same number of values as the actual_samples+1 -->
        <ramp>
            <input as="start" type="value">0</input>
            <input as="stop" clear="false">arate</input>
            <input as="length" clear="false">actual_samples+1</input>
            <output>frequency</output>
        </ramp>

        <!-- returns all values from 1 to count/2 to give half the normal output values (for x-component) -->
        <subrange>
            <input as="from" type="value">1</input>
            <input as="to" clear="false">count/2</input>
            <input as="in" clear="false">frequency</input>
            <input as="in">fftXX</input>
            <input as="in">fftXY</input>
            <output>halfFrequency</output>
            <output>halfFFTtempX</output>
            <output>halfFFTtempY</output>
        </subrange>
        
        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempX</input>
            <input>halfFFTtempX</input>
            <output>halfFFTtempX2</output>
        </multiply>

        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempY</input>
            <input>halfFFTtempY</input>
            <output>halfFFTtempY2</output>
        </multiply>

        <!-- adds the X and Y halves together to give ffX -->
        <add>
            <input>halfFFTtempX2</input>
            <input>halfFFTtempY2</input>
            <output>fftX</output>
        </add>

        <!-- returns all values from 1 to count/2 to give half the normal output values (for y-component) -->
        <subrange>
            <input as="from" type="value">1</input>
            <input as="to" clear="false">count/2</input>
            <input as="in" clear="false">frequency</input>
            <input as="in">fftYX</input>
            <input as="in">fftYY</input>
            <output>halfFrequency</output>
            <output>halfFFTtempX</output>
            <output>halfFFTtempY</output>
        </subrange>

        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempX</input>
            <input>halfFFTtempX</input>
            <output>halfFFTtempX2</output>
        </multiply>

        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempY</input>
            <input>halfFFTtempY</input>
            <output>halfFFTtempY2</output>
        </multiply>
    
        <!-- adds the X and Y halves together to give fftY -->
        <add>
            <input>halfFFTtempX2</input>
            <input>halfFFTtempY2</input>
            <output>fftY</output>
        </add>

        <!-- returns all values from 1 to count/2 to give half the normal output values (for z-component) -->
        <subrange>
            <input as="from" type="value">1</input>
            <input as="to" clear="false">count/2</input>
            <input as="in" clear="false">frequency</input>
            <input as="in">fftZX</input>
            <input as="in">fftZY</input>
            <output>halfFrequency</output>
            <output>halfFFTtempX</output>
            <output>halfFFTtempY</output>
        </subrange>
        
        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempX</input>
            <input>halfFFTtempX</input>
            <output>halfFFTtempX2</output>
        </multiply>

        <!-- squares -->
        <multiply>
            <input clear="false">halfFFTtempY</input>
            <input>halfFFTtempY</input>
            <output>halfFFTtempY2</output>
        </multiply>

        <!-- adds the X and Y halves together to give fftZ -->
        <add>
            <input>halfFFTtempX2</input>
            <input>halfFFTtempY2</input>
            <output>fftZ</output>
        </add>
           
        <!-- sums fftX, fftY, fftX inputs together to the single output buffer fft2 -->
        <add> 
            <input>fftX</input>
            <input>fftY</input>
            <input>fftZ</input>
            <output>fft2</output>
        </add>
          
        <!-- square roots -->
        <power>
            <input as="base">fft2</input>
            <input as="exponent" type="value">0.5</input>
            <output>fft</output>
        </power>
		
        <!-- calculates the maximum fft value -->
		<max> 
			<input as="y" clear="false">fft</input>
			<output as="max">maxfft</output>
        </max>
		
        <!-- returns the x-position of the maxfft value to give the peak frequency -->
        <max> 
          <input as="y" clear="false">fft</input>
          <input as="x" clear="false">halfFrequency</input>
          <output as="position" clear="false">f0</output>
        </max>
		
		<!-- calculates the average and the standard deviation of the maxfft -->
		<average>
			<input clear="false">maxfft</input>
			<output as="average" clear="false">maxfft_avg</output> <!-- calculates the average max FFT value -->
			<output as="stddev">maxfft_error</output> <!-- calculates the standard deviation of the max FFT value -->
		</average>
		
        <!-- calculates the average and the standard deviation of the peak frequency -->
		<average>
			<input clear="false">f0</input>
			<output as="average" clear="false">f0_avg</output> <!-- calculates the average peak frequency -->
			<output as="stddev">f0_error</output> <!-- calculates the standard deviation of the peak frequency -->
		</average>
      </analysis>


    <!-- for exporting to Excel -->
    <export>
        <set name="Accelerations">
            <data name="Time (s)">time_subrange</data>
            <data name="Acceleration x (m/s²)">accX_subrange</data>
            <data name="Acceleration y (m/s²)">accY_subrange</data>
            <data name="Acceleration z (m/s²)">accZ_subrange</data>
        </set>

        <set name="FFT Graph">
            <data name="Frequency (Hz)">halfFrequency</data>
            <data name="FFT (a.u.)">fft</data>
            <data name="Peak Frequency (Hz)">f0</data>
	    <data name="Max FFT (a.u.)">maxfft</data>
        </set>
		
	<set name="Stats">
            <data name="Avg Peak Frequency (Hz)">f0_avg</data>
            <data name="Avg Peak Frequency Error (Hz)">f0_error</data>
	    <data name="Max FFT (a.u.)">maxfft_avg</data>
	    <data name="Max FFT Error (a.u.)">maxfft_error</data>
        </set>
    </export>
</phyphox>
